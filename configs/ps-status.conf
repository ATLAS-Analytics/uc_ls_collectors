input { pipeline { address => "ps-status" } }

filter {

  if [type]=="meta" {
    mutate { 
      add_field => { "[@metadata][type]" => "meta" } 
      convert => { "[configuration][allow_internal_addresses]" => "boolean" }
      convert => { "[services][esmond][enabled]" => "boolean" }
      convert => { "[services][lsregistration][enabled]" => "boolean" }
      convert => { "[services][owamp][enabled]" => "boolean" }
      convert => { "[services][pscheduler][enabled]" => "boolean" }
      convert => { "[services][psconfig][enabled]" => "boolean" }
      convert => { "[services][twamp][enabled]" => "boolean" }
    }
  }
  else if [type]=="status" {
    mutate { add_field => { "[@metadata][type]" => "status" } }
  }
  else {
    drop{ }
  }

  mutate {
    remove_field => [ "headers", "@version", "host"]
    copy => { "@timestamp" => "ingest_timestamp" }
  }
  
  memcached {
    hosts => ["memcached"]
    get => {
      "vo_%{[ps_host]}" => "[VO]"
      "sitename_%{[ps_host]}" => "[site]"
      "rcsite_%{[ps_host]}" => "[rcsite]"
      "production_%{[ps_host]}" => "[production]"
    }
  }
  
  mutate { 
    rename => { "ps_host" => "[host]" } 
  }
  
  if ![tags] { # for problematic things don't remove fields
    mutate{
      remove_field => ["type", "@timestamp"] 
    }
  }

}

output {

  stdout {
    codec => json
  }

  if "_jsonparsefailure" in [tags] {
    file {
      path => "/var/log/logstash/json_parse_failure.txt"
    }
  }

  elasticsearch {
    hosts => "atlas-kibana.mwt2.org"
    data_stream => false
    ssl => true
    index => 'test_ps_%{[@metadata][type]}'
    user => "uc_logstash_indexer"
    password => "${LOGSTASH_PWD}"
  }

}
