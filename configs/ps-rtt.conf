input { pipeline { address => "ps-rtt" } }

filter {
  
  if ![result][succeeded] {
    drop{ }
  }

  if [source][ipv6] and [destination][ipv6] {
    mutate { 
      add_field => { "ipv6" => true } 
      add_field => { "src" => "%{[source][ipv6]}" } 
      add_field => { "dest" => "%{[destination][ipv6]}" } 
    }
  } else {
    mutate { 
      add_field => { "ipv6" => false } 
      add_field => { "src" => "%{[source][ipv4]}" } 
      add_field => { "dest" => "%{[destination][ipv4]}" } 
      }
  }

  mutate {
    add_field => { "[@metadata][type]" => "ps_rtt_write" } 
    remove_field => [ "headers", "@version"]
    uppercase => [ "VO" ]
    convert => { "production" => "boolean" }
    copy => { "@timestamp" => "ingest_timestamp" }
    copy => { "[result][reorders]" => "reorders" }
    copy => { "[result][received]" => "received" }
    copy => { "[result][loss]" => "loss" }
    copy => { "[result][lost]" => "lost" }
    copy => { "[result][sent]" => "sent" }
    copy => { "[result][duplicates]" => "duplicates" }
  }

  if [result][roundtrips]{
    ruby {
        code => '
            rttArray = event.get("[result][roundtrips][rtt]")
            if rttArray
                newRttArray = []
                rttArray.each { |x|
                    newRttArray << x[2,6].to_f
                }
                event.set("rtt", newRttArray)
            end
        '
    }
  }

  uuid {
    target    => "[@metadata][id]"
  }

  if ![tags] { # for problematic things don't remove fields
    mutate{
      remove_field => ["type", "test", "result", "@timestamp"] 
      convert => { "ipv6" => "boolean" }
    }
  }

}

output {
  pipeline { send_to => ["es-output"] }
}
